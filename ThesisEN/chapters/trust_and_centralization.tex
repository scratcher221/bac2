 \chapter{The Problem of Trust and Centralization}
 \label{cha:trust_and_centralization}
 \section{Why Centralized Control is Undesirable in this Project}
 The reason for building a decentralized application is mainly that users don't have to trust a central authority with their money and their data. Another reason is that users can rely on the integrity of the data provided by the distributed system. In the fully decentralized peer-to-peer model, there is no central point that can be attacked or tampered with. So the end user can be sure that the data they received from one of the nodes of the network is authentic, or at least they can verify this with digital signatures.
 
 However, if there is a central instance that provides the data, as is the case in the current state of the project, users can never be sure that this central source has not been compromised. As of now, the power lies in the hands of the administrators who control what games users can bet on, and also the results of these games. While security precautions have been taken to ensure that not \emph{anyone} can alter game results or manipulate bets, since only the creators of the \texttt{BetManager} contract on the blockchain can call the functions responsible for this, there is still the possibility of the administrators being bribed, or their private keys being stolen. Furthermore, the administrators could take advantage of their power and use their control for personal financial gain, by providing game results they have bet on, etc.
 
 For all these reasons mentioned above, in its current state, the project ultimately defeats the purpose of being provided on a decentralized platform because it still sources crucial data from a central hand. The whole point of blockchain systems is to not have this central point. Systems built based on the traditional model with a central instance have many advantages like better speed, latency and throughput compared to those novel platforms. The factor of having no single controlling instance is essential and must be preserved in order to not defeat the purpose of this project. The target user, which is someone who rejects centralization in favor of decentralized, distributed systems, can not be satisfied with the system as it is. Countermeasures need to be taken and solutions provided to mitigate these issues. This is where so called \emph{Blockchain Oracles} come in.
 \section{The Concept of Blockchain Oracles}
 In order to receive data from the world outside of the Ethereum network, there needs to be a way for smart contracts to be able to interact with regular web servers, for example through APIs that can be queried over regular HTTP or HTTPS. Blockchain applications themselves cannot directly fetch the data they require, like price feeds, weather data, sports game results, election results, etc. A blockchain oracle is basically just a connector that makes this possible. Usually, the oracle itself is also a contract deployed on the blockchain, that can be accessed at its contract address, and queried through specific methods \cite{oraclizedoc}. There are a number of different implementations of such oracles, for various blockchain platforms.
 \begin{table}[ht]
	\centering
	\begin{tabular}{ | l | l | l | l |}
		\hline
		\multicolumn{4}{ | c | }{\textbf{Blockchain Oracle Implementations}} \\ \hline
		\emph{Blockchain Protocol} & \emph{Orisi} & \emph{Town Crier} & \emph{Oraclize} \\ \hline
		\textbf{Bitcoin} & yes & no & yes \\ \hline
		\textbf{Ethereum} & no & yes & yes \\ \hline
		\textbf{Rootstock} & no & no & yes \\ \hline
		\textbf{EOS} & no & no & yes \\ \hline
		\textbf{R3 Corda} & no & no & yes \\ \hline
		\textbf{Hyperledger} & no & no & yes \\ \hline
		\textbf{Fabric} & no & no & yes \\ \hline
	\end{tabular}
	\caption{\label{tab:blockchain-oracles}Blockchain platforms supported by various oracles \cite{zhangtown}\cite{oraclizedoc}\cite{orisiwhitepaper}}
\end{table}
\\
In the table above, it becomes apparent that the most versatile oracle clearly is the \emph{Oraclize} implementation. This service, \emph{Oraclize}, will be used in the cryptocurrency sportsbetting app, because it provides an extensive documentation and a rich interface. 
\section{Existing Solutions}
\subsection{Oraclize}
Oraclize is the leading oracle service in the blockchain space, supporting a variety of platforms, and even non-blockchain applications \cite{oraclizedoc}. It provides a solution which can demonstrate that the data fetched from the third party source, for example over an API request, has not been manipulated. So called \emph{Authenticity Proofs} are used to accomplish this.
\subsection*{Authenticity Proofs}
In order to guarantee data integrity, a document can be requested from a smart contract in addition to the desired third party data, which is a strong cryptographic guarantee providing that the data has not been tampered with. For this, the trust is shifted away from Oraclize, to technology providers or device manufacturers with good reputation and a lot at stake. An example is the \emph{Ledger proof}, which uses the hardware attestation feature provided by BOLOS, to enable code execution on the Ledger platform. BOLOS is a crypto-embedded operating system built for Secure Elements and Secure Enclaves. Ledger, which is a hardware manufacturer for cryptocurrency cold storage, is a device manufacturer with good reputation and a lot at stake. This is one example of how an authenticity proof might be generated. The Oraclize service currently implements three different types of authenticity proofs:
\begin{itemize}
	\item TLSNotary Proof
	\item Android Proof
	\item Ledger Proof
\end{itemize}
\subsection*{TLSNotary Proof}
\emph{TLSNotary} is an open-source protocol and a mechanism for independently audited HTTPS sessions. The technology is developed and used by the \emph{PageSigner} project\cite{pagesigner}. 

It works by splitting the TLS master key between the auditee (in this case Oraclize) and the auditor (in this case a locked-down AWS instance of an open-source Amazon Machine Image). In this way, it is possible for the auditee, Oraclize, to prove to the auditor that certain web traffic has occurred between them and a server. The server would be the data source requested by the issuer of the "oraclize\textunderscore query" call, such as a machine that serves data over a REST API URL. This authenticity proof is indisputable, provided the auditor trusts the public key of the server (the data source).\cite{tlsnotarywhitepaper}\cite{oraclizedoc}

The basic steps of how the TLS secret data is split into two parts, and the control flow of how the auditor makes sure that the auditee doesn't produce manipulated data, are illustrated in the following figures:

\begin{figure}[H]
\centering
\includegraphics[scale=0.55]{tlsnotary_secret_splitting}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.55]{tlsnotary_secret_splitting_2}
\caption{Control flow of the TLS secret splitting and auditing process. \cite{tlsnotarywhitepaper}}
\end{figure}

This series of complex steps is done so that the auditee (Oraclize) cannot create a fake version of the HTTP traffic from the server, since they do not have the server mac key. Only once the auditor releases the remaining 20 bytes of the expanded key block (generated from the master secret key halves), the auditee can complete the TLS decryption and authentication steps, view the data, and forward it to the issuer of the oraclize request. 

In this way, the creator of a smart contract using Oraclize can be sure that the data forwarded by this service has not been tampered with and is authentic.
\subsection*{Android Proof}
Android Proof is another type of Oraclize's authenticity proofs. It uses Google's \emph{SafetyNet} Software Attestation and Android Hardware Attestation in order to provide an environment that is secure and auditable, which can deliver reliable data.

The basic concept is to use a service application, which is running on a trusted physical Android device, to fetch and deliver this data. The integrity of this device is guaranteed by \emph{SafetyNet}, which can prove that the list of root certificate authorities stored on the device has not been modified. It does this by verifying the full chain of certificates against publicly available certificate revocation lists owned by Google. \emph{SafetyNet} can also detect whether an Android device is in a tampered state or not.

Another important part of this type of proof is the Hardware Attestation Object, which is required to prove that the key has been generated inside the KeyStore of the trusted physical Android device.

The process of retrieving data from an API while using the Android Proof attestation can be outlined in the following way:
\begin{itemize}
	\item The URL provided by the user is sent to the trusted Android device. The service application running on this device then establishes a HTTPS connection with this URL, and the entire response is retrieved from the server. Then the SHA256 hash of this response is calculated and signed by the application, using the hardware attested key pair from the Android KeyStore on this device.
	\item A call to Google's SafetyNet API is made using the data from before as parameter. The API returns an \emph{AttestationResponse} in the JSON Web Signature format (JWS).
	\item The service application running on the trusted device then sends the entire JWS response, the HTTPS response with it's SHA256 signature and the requestID to Oraclize. There the proof is validated and the data from the HTTPS response is forwarded to the user. The SafetyNet AttestationResponse and the Hardware Attestation Object are also sent to the user.
\end{itemize}

The following picture demonstrates this process in a simplified way:
\begin{figure}[H]
\centering
\includegraphics[scale=0.75]{android_proof_process}
\caption{Oraclize API request using Android Proof\cite{androidproof}}
\end{figure}
This type of authenticity proof can be verified by any third party by checking the following elements:
\begin{itemize}
	\item JWS Verification, this can be done by validating the certificate chain found in the JWS Header against a certificate revocation list by a known root certificate authority.
	\item SafetyNet Authenticity. For this, the Google Device Verification API can be consulted to check if the JWS has indeed been generated by Google.
	\item SatetyNet Response Verification
	\item Hardware Attestation Verification
\end{itemize}

In order for the Android Proof to be a suitable method for guaranteeing data authenticity, a number of features of the Android platform are utilized. Worth mentioning here are the Android Hardware Keystore and the Hardware Attestation, first implemented in Android Nougat. Both features are implemented in a TEE (Trusted Execution Environment). Furthermore, the concept relies on Google's SafetyNet Software Attestation APIs and the Android App Sandbox model. It is assumed that this model is secure and prevents apps from manipulating memory or data that do not belong to them. This sandbox model is one of the key features of the Android OS. Google's SafetyNet is a feature which can be used by developers to check whether a device is in a tampered (rooted, monitored, infected with malware) state or not.

The steps of generating this Android Proof are outlined in more detail in the following graph, taken from the Android Proof whitepaper by Oraclize.

\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{android_proof_detailed_graph}
\caption{A detailed graph showing how the Android Proof is generated and verified\cite{androidproof}}
\end{figure}
\subsection*{Ledger Proof}
The third kind of authenticity proof provided by the Oraclize service is called \emph{Ledger Proof}. \emph{Ledger} is a French company specializing in the field of producing hardware-enforced cryptocurrency wallets. Their flagship product is the Ledger Nano S. Their devices are equipped with a STMicroelectronics secure element, a controller and the operating system \emph{BOLOS}. Developers can build applications for this OS using the BOLOS-SDK.

The feature in the \emph{BOLOS} operating system which is important to Oraclize is the kernel-level API which can conduct cryptographic operations and attestations. The attestation feature enables any application, by querying the appropriate API, to retrieve a signed hash of the kernel binary. This hash is signed using a key which is controlled by the BOLOS kernel and can not be accessed by the application developer. Furthermore, this key has a full chain of trust with the root in a master key that resides on a hardware security module controlled by Ledger.

These features of the BOLOS operating system are utilized by Oraclize to attest to the user of the Oraclize query system that the applications built by Oraclize are indeed running in a trusted execution environment (TEE) of a true Ledger device\cite{oraclizedoc}.


There are tools available to verify the proofs generated by Oraclize \cite{oraclizeproofverify}.
\subsection*{Oraclize Engine}
The basis for the functionality of the Oraclize service is the \emph{Oraclize Engine}. Internally, it replicates a logical, conditional model. Thus, certain conditions can be verified repeatedly and data will only be returned if those conditions are met. In order to form a valid request, the engine needs to be provided with at least two, or optionally three arguments:
\begin{itemize}
	\item A data source type
	\item A query
	\item (Optional) An authenticity proof type
\end{itemize} 
Those arguments are passed as string arguments to the \texttt{oraclize\textunderscore query} function call. An example call could look like this:

\texttt{oraclize\textunderscore query("URL", "xml(https://www.example.at/api).element");}
\subsection*{Data Source Types}
In the example above, the data source type was "URL", however Oraclize supports various other types, such as\cite{oraclizedoc}
\begin{itemize}
	\item WolframAlpha: native access to WolframAlpha engine
	\item IPFS: access to any file stored on IPFS (InterPlanetary File System)
	\item Random: provides random data utilizing the Ledger Authenticity Proof type
	\item Computation: the result of a computation specified by the issuer of the query
\end{itemize}
Furthermore there are meta data source types, including:
\begin{itemize}
	\item Nested: used for nesting multiple data source types of different kind, or multiple requests to one source, returns one unified result
	\item Identity: returns the query
	\item Decrypt: decrypts data which was encrypted with the Oraclize private key
\end{itemize}
\subsection*{Queries}
The query is the central element to be used in the Oraclize engine. It specifies the details of the request containing information where the data is to be retrieved from, for example a specific URL.

On a technical level, the query is an array of parameters, with the first one being mandatory. An example is the URL where a certain resource is located. However, the result of this query may not be suitable in the original format, it may need to be parsed. For this, Oraclize provides parsing helpers, which can be specified within the query.
\subsection*{Query Parsing Helpers}
There are JSON, XML, XHTML and binary parsing helpers offered by the Oraclize service. They are used by prefixing the name of the data format (e.g. "json") to the query and appending object, tag names or operators, depending on the format. An example using a parsing helper for binary data source types could look like this: 

\texttt{binary(http://www.siemens.com/pki/ZZZZZZVS.crl).slice(0,300)}

The parameters of the slice operator are \texttt{(offset, length)}. This example will return the first 300 bytes in this binary file.
\subsection{Astraea}
Astraea is a decentralized blockchain oracle, described in a paper by John Adler et al., however it has never been implemented as a real world service. Other than Oraclize, it is not an intermediary for fetching data from third party sources, but attempts to deliver data based on a voting game that decides the truth or falsity of propositions.

In the proposed system, there are players (submitters, voters and certifiers) that behave in the following way:
\begin{itemize}
	\item Submitters allocate money to fund propositions that get voted on
	\item Voters submit deposits, and are given the chance to vote on one of the available propositions, chosen at random. The maximum amount a voter can deposit is a parameter of the system.
	\item Certifiers choose an available proposition, and place a large deposit in order to certify its truth or falsity. The minimum deposit for a certification is a system parameter and should be large enough to carry a certain risk.
\end{itemize}
In the paper it is shown that such a system can be set up in a way that manipulation by an adversary is almost impossible, even if the adversary contains up to 25\% of all votes\cite{astraea}.

\subsection{ChainLink}
\emph{ChainLink} is another provider of oracle services in the blockchain space. Currently, the service is available only on the Ethereum test networks, that is Ropsten, Rinkeby and Kovan.

One unique characteristic of \emph{ChainLink} is that the service utilizes the dedicated \emph{LINK} token to carry out transactions. 
\subsection*{Requirements for requesting data}
In order to request data using the ChainLink oracle, some requirements need to be met:
\begin{itemize}
	\item The contract which carries out the request needs to be funded with  LINK tokens. On the test networks, one LINK token amounts to one request.
	\item Depending on the type of data to be requested, a "Job ID" needs to be specified. This is different on every network.
\end{itemize}
For testing purposes, LINK tokens can be obtained from a faucet, which is a contract that gives out free tokens. An example for this is a faucet that runs on the Ropsten testnet, accessible via HTTP at \texttt{https://ropsten.chain.link/}. The address of the contract which calls the request function of the ChainLink contract is entered into the input field on this website, in order to receive LINK tokens.

The "Job ID" for each type of data is found in the ChainLink documentation: \texttt{https://docs.chain.link/docs/addresses-and-job-specs}. For instance, if the contract owner wants to request boolean data, the corresponding "Job ID" would be
 
\texttt{7ac0b3beac2c448cb2f6b2840d61d31f}. It is advisable to store those jobs ids in a constant in the contract, like this:
\begin{figure}[H]
\includegraphics[scale=0.965]{chainlink_jobid}
\end{figure}
To specify HTTP POST or GET parameters, or to navigate through a JSON object, methods within \texttt{Chainlink.Request} can be used. For example, to fetch the current Ethereum USD price over an API, the function can look as follows:
\begin{figure}[H]
\includegraphics[scale=1]{chainlink_req_price}
\end{figure}
\subsection*{Receiving data}
In the \texttt{requestPrice} function implemented previously, a callback function that has been assigned to \texttt{requestId} is returned. This function is triggered, when the Chainlink network responds to the query with a result. 
\subsection*{External Adapters}
Chainlink provides a feature called "External Adapters". Basically, these adapters represent the bridge between the Chainlink node, which handles, amongst other things, signing transactions for the blockchain and writing to the blockchain, and complex external APIs that may require some form of authentication.

Publicly open APIs can be read by the Chainlink node directly, without any adapters. However, some APIs require authentication with sensitive credentials. These should not be stored on the Chainlink node directly, as that would pose a security risk. Credentials can be stored in whatever way it is specified in the external adapter.

Furthermore, these adapters can include additional functionality. They can be written in any language\cite{chainlinkdoc}.
\subsection*{Architecture Overview}
The Chainlink system architecture is outlined in a simplified way in the following figure:
\begin{figure}[H]
\includegraphics[scale=0.6]{chainlink_architecture}
\caption{The ChainLink system architecture, as described in the official documentation\cite{chainlinkdoc}}
\end{figure}

\section{Implementation of an Oracle in the App}
The Oracle connector used in the project is the \emph{Oraclize} service. Mainly, the functionality for the purposes of a cryptocurrency sportsbetting app is implemented in the Solidity contract \texttt{OracleObserver.sol}.
