 \chapter{The Problem of Trust and Centralization}
 \label{cha:trust_and_centralization}
 \section{Why Centralized Control is Undesirable in this Project}
 The reason for building a decentralized application is mainly that users don't have to trust a central authority with their money and their data. Another reason is that users can rely on the integrity of the data provided by the distributed system. In the fully decentralized peer-to-peer model, there is no central point that can be attacked or tampered with. So the end user can be sure that the data they received from one of the nodes of the network is authentic, or at least they can verify this with digital signatures.
 
 However, if there is a central instance that provides the data, as is the case in the current state of the project, users can never be sure that this central source has not been compromised. As of now, the power lies in the hands of the administrators who control what games users can bet on, and also the results of these games. While security precautions have been taken to ensure that not \emph{anyone} can alter game results or manipulate bets, since only the creators of the \texttt{BetManager} contract on the blockchain can call the functions responsible for this, there is still the possibility of the administrators being bribed, or their private keys being stolen. Furthermore, the administrators could take advantage of their power and use their control for personal financial gain, by providing game results they have bet on, etc.
 
 For all these reasons mentioned above, in its current state, the project ultimately defeats the purpose of being provided on a decentralized platform because it still sources crucial data from a central hand. The whole point of blockchain systems is to not have this central point. Systems built based on the traditional model with a central instance have many advantages like better speed, latency and throughput compared to those novel platforms. The factor of having no single controlling instance is essential and must be preserved in order to not defeat the purpose of this project. The target user, which is someone who rejects centralization in favor of decentralized, distributed systems, can not be satisfied with the system as it is. Countermeasures need to be taken and solutions provided to mitigate these issues. This is where so called \emph{Blockchain Oracles} come in.
 \section{The Concept of Blockchain Oracles}
 In order to receive data from the world outside of the Ethereum network, there needs to be a way for smart contracts to be able to interact with regular web servers, for example through APIs that can be queried over regular HTTP or HTTPS. Blockchain applications themselves cannot directly fetch the data they require, like price feeds, weather data, sports game results, election results, etc. A blockchain oracle is basically just a connector that makes this possible. Usually, the oracle itself is also a contract deployed on the blockchain, that can be accessed at its contract address, and queried through specific methods \cite{oraclizedoc}. There are a number of different implementations of such oracles, for various blockchain platforms.
 \begin{table}[ht]
	\centering
	\begin{tabular}{ | l | l | l | l |}
		\hline
		\multicolumn{4}{ | c | }{\textbf{Blockchain Oracle Implementations}} \\ \hline
		\emph{Blockchain Protocol} & \emph{Orisi} & \emph{Town Crier} & \emph{Oraclize} \\ \hline
		\textbf{Bitcoin} & yes & no & yes \\ \hline
		\textbf{Ethereum} & no & yes & yes \\ \hline
		\textbf{Rootstock} & no & no & yes \\ \hline
		\textbf{EOS} & no & no & yes \\ \hline
		\textbf{R3 Corda} & no & no & yes \\ \hline
		\textbf{Hyperledger} & no & no & yes \\ \hline
		\textbf{Fabric} & no & no & yes \\ \hline
	\end{tabular}
	\caption{\label{tab:blockchain-oracles}Blockchain platforms supported by various oracles \cite{zhangtown}\cite{oraclizedoc}\cite{orisiwhitepaper}}
\end{table}
\\
In the table above, it becomes apparent that the most versatile oracle clearly is the \emph{Oraclize} implementation. This service, \emph{Oraclize}, will be used in the cryptocurrency sportsbetting app, because it provides an extensive documentation and a rich interface. 
\section{Existing Solutions}
\subsection{Oraclize}
Oraclize is the leading oracle service in the blockchain space, supporting a variety of platforms, and even non-blockchain applications \cite{oraclizedoc}. It provides a solution which can demonstrate that the data fetched from the third party source, for example over an API request, has not been manipulated. So called \emph{Authenticity Proofs} are used to accomplish this.
\subsection*{Authenticity Proofs}
In order to guarantee data integrity, a document can be requested from a smart contract in addition to the desired third party data, which is a strong cryptographic guarantee providing that the data has not been tampered with. For this, the trust is shifted away from Oraclize, to technology providers or device manufacturers with good reputation and a lot at stake. An example is the \emph{Ledger proof}, which uses the hardware attestation feature provided by BOLOS, to enable code execution on the Ledger platform. BOLOS is a crypto-embedded operating system built for Secure Elements and Secure Enclaves. Ledger, which is a hardware manufacturer for cryptocurrency cold storage, is a device manufacturer with good reputation and a lot at stake. This is one example of how an authenticity proof might be generated. The Oraclize service currently implements three different types of authenticity proofs:
\begin{itemize}
	\item TLSNotary Proof
	\item Android Proof
	\item Ledger Proof
\end{itemize}
\subsection*{TLSNotary Proof}
\emph{TLSNotary} is an open-source protocol and a mechanism for independently audited HTTPS sessions. The technology is developed and used by the \emph{PageSigner} project\cite{pagesigner}. 

It works by splitting the TLS master key between the auditee (in this case Oraclize) and the auditor (in this case a locked-down AWS instance of an open-source Amazon Machine Image). In this way, it is possible for the auditee, Oraclize, to prove to the auditor that certain web traffic has occurred between them and a server. The server would be the data source requested by the issuer of the "oraclize\textunderscore query" call, such as a machine that serves data over a REST API URL. This authenticity proof is indisputable, provided the auditor trusts the public key of the server (the data source).\cite{tlsnotarywhitepaper}\cite{oraclizedoc}

The basic steps of how the TLS secret data is split into two parts, and the control flow of how the auditor makes sure that the auditee doesn't produce manipulated data, are illustrated in the following figures:

\begin{figure}[H]
\centering
\includegraphics[scale=0.55]{tlsnotary_secret_splitting}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[scale=0.55]{tlsnotary_secret_splitting_2}
\caption{Control flow of the TLS secret splitting and auditing process. \cite{tlsnotarywhitepaper}}
\end{figure}

This series of complex steps is done so that the auditee (Oraclize) cannot create a fake version of the HTTP traffic from the server, since they do not have the server mac key. Only once the auditor releases the remaining 20 bytes of the expanded key block (generated from the master secret key halves), the auditee can complete the TLS decryption and authentication steps, view the data, and forward it to the issuer of the oraclize request. 

In this way, the creator of a smart contract using Oraclize can be sure that the data forwarded by this service has not been tampered with and is authentic.
\subsection*{Android Proof}
Android Proof is another type of Oraclize's authenticity proofs. It uses Google's \emph{SafetyNet} Software Attestation and Android Hardware Attestation in order to provide an environment that is secure and auditable, which can deliver reliable data.

The basic concept is to use a service application, which is running on a trusted physical Android device, to fetch and deliver this data. The integrity of this device is guaranteed by \emph{SafetyNet}, which can prove that the list of root certificate authorities stored on the device has not been modified. It does this by verifying the full chain of certificates against publicly available certificate revocation lists owned by Google. \emph{SafetyNet} can also detect whether an Android device is in a tampered state or not.

Another important part of this type of proof is the Hardware Attestation Object, which is required to prove that the key has been generated inside the KeyStore of the trusted physical Android device.

The process of retrieving data from an API while using the Android Proof attestation can be outlined in the following way:
\begin{itemize}
	\item The URL provided by the user is sent to the trusted Android device. The service application running on this device then establishes a HTTPS connection with this URL, and the entire response is retrieved from the server. Then the SHA256 hash of this response is calculated and signed by the application, using the hardware attested key pair from the Android KeyStore on this device.
	\item A call to Google's SafetyNet API is made using the data from before as parameter. The API returns an \emph{AttestationResponse} in the JSON Web Signature format (JWS).
	\item The service application running on the trusted device then sends the entire JWS response, the HTTPS response with it's SHA256 signature and the requestID to Oraclize. There the proof is validated and the data from the HTTPS response is forwarded to the user. The SafetyNet AttestationResponse and the Hardware Attestation Object are also sent to the user.
\end{itemize}

The following picture demonstrates this process in a simplified way:
\begin{figure}[H]
\centering
\includegraphics[scale=0.75]{android_proof_process}
\caption{Oraclize API request using Android Proof\cite{androidproof}}
\end{figure}
This type of authenticity proof can be verified by any third party by checking the following elements:
\begin{itemize}
	\item JWS Verification, this can be done by validating the certificate chain found in the JWS Header against a certificate revocation list by a known root certificate authority.
	\item SafetyNet Authenticity. For this, the Google Device Verification API can be consulted to check if the JWS has indeed been generated by Google.
	\item SatetyNet Response Verification
	\item Hardware Attestation Verification
\end{itemize}

In order for the Android Proof to be a suitable method for guaranteeing data authenticity, a number of features of the Android platform are utilized. Worth mentioning here are the Android Hardware Keystore and the Hardware Attestation, first implemented in Android Nougat. Both features are implemented in a TEE (Trusted Execution Environment). Furthermore, the concept relies on Google's SafetyNet Software Attestation APIs and the Android App Sandbox model. It is assumed that this model is secure and prevents apps from manipulating memory or data that do not belong to them. This sandbox model is one of the key features of the Android OS. Google's SafetyNet is a feature which can be used by developers to check whether a device is in a tampered (rooted, monitored, infected with malware) state or not.

The steps of generating this Android Proof are outlined in more detail in the following graph, taken from the Android Proof whitepaper by Oraclize.

\begin{figure}[H]
\centering
\includegraphics[scale=0.65]{android_proof_detailed_graph}
\caption{A detailed graph showing how the Android Proof is generated and verified\cite{androidproof}}
\end{figure}
\subsection*{Ledger Proof}
The third kind of authenticity proof provided by the Oraclize service is called \emph{Ledger Proof}. 


There are tools available to verify the proofs generated by Oraclize \cite{oraclizeproofverify}.
\subsection*{Oraclize Engine}
The basis for the functionality of the Oraclize service is the \emph{Oraclize Engine}. Internally, it replicates a logical, conditional model. Thus, certain conditions can be verified repeatedly and data will only be returned if those conditions are met. In order to form a valid request, the engine needs to be provided with at least two, or optionally three arguments:
\begin{itemize}
	\item A data source type
	\item A query
	\item (Optional) An authenticity proof type
\end{itemize} 
Those arguments are passed as string arguments to the \texttt{oraclize\textunderscore query} function call. An example call could look like this:

\texttt{oraclize\textunderscore query("URL", "xml(https://www.example.at/api).element");}
